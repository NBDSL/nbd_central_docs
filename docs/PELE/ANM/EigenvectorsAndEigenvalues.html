
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Treatment of eigenvector and eigenvalues by the PELE ANM module &#8212; PELE 1.5.${BUILD_TAG} documentation</title>
    <link rel="stylesheet" href="../_static/naturemodified.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.5.${BUILD_TAG}',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SideChainPrediction Block in Pele++ control file" href="../SideChainPrediction/SideChainPrediction.html" />
    <link rel="prev" title="ANM Block in Pele++ control file" href="Anm.html" /> 
    <script type="text/javascript" >
    MathJax.Hub.Config({
        TeX: { 
	  Macros: {
	    AA: '{\\unicode{xC5}}'
	  }
	}
    });
    </script>

  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../SideChainPrediction/SideChainPrediction.html" title="SideChainPrediction Block in Pele++ control file"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Anm.html" title="ANM Block in Pele++ control file"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PELE 1.5.${BUILD_TAG} documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../referenceManual.html" >Reference Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../PELE/PELESimulation_index.html" accesskey="U">PELESimulation command</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="treatment-of-eigenvector-and-eigenvalues-by-the-pele-anm-module">
<h1>Treatment of eigenvector and eigenvalues by the PELE ANM module<a class="headerlink" href="#treatment-of-eigenvector-and-eigenvalues-by-the-pele-anm-module" title="Permalink to this headline">¶</a></h1>
<p>The eigenvectors of the hessian matrix are used by the ANM algorithm in
order to calculate the displacement vector for each node. The sequence
of steps that PELE follows when dealing with eigenvectors in order to
calculate the final displacement vector is the following:</p>
<ul class="simple">
<li>The eigenvectors, and they corresponding eigenvalues, are computed
both at the same time.</li>
<li>The vectors are normalized.</li>
<li>A mode is chosen among the set of eigenvectors</li>
<li>For the selected mode, a new direction is set.</li>
<li>The chosen mode is scaled to a certain modulus.</li>
<li>A final direction vector is obtained mixing the selected mode with
the other ones.</li>
<li>For each atom, a target position is calculated using the previously
calculated move vector.</li>
<li>A set of harmonic constraints is added to energy computation
function. The equilibrium position for each constraint (i.e. for each
atom) is the target position obtained at the previous step, while the
“k” constant is the same for all the constraints.</li>
</ul>
<p>The previous sequence of steps describes the algorithm, but the actual
procedure that is followed at each step is parameterizable by the user.
So the user can choose how the vector will be normalized or how the
modulus will be calculated for the selected mode. All the options are
intercheangeable, leading to a wide range of combinations. Information
about each specific option can be obtained in PELE’s documentation.</p>
<p>The purpose of the eigenvectors in the previous algorithm is clear: a
prefered normal mode will be chosed among them. The eigenvalues,
however, may or may not be used, depending on the algorithms chosen by
the user for each step.</p>
<p>The following section explains which are the places where eigenvalues
are used, and for each one, indicates in an algorithmic way the math
that is performed, and also which parameteres have to be enabled in
order to perform the calculation:</p>
<p>From now on, <code class="docutils literal"><span class="pre">values</span></code> refers to the array of eigenvalues, and
<code class="docutils literal"><span class="pre">vectors</span></code> refers to the array of eigenvectors (both with dimension
<code class="docutils literal"><span class="pre">numberOfModes</span></code>). Functions like <code class="docutils literal"><span class="pre">inverseEuclideanNorm</span></code>,
<code class="docutils literal"><span class="pre">vectorByScalar</span></code>, etc. represent the mathematical functions they are
called after. Also <code class="docutils literal"><span class="pre">sqrt</span></code> means squareroot, and <code class="docutils literal"><span class="pre">rand(arg,</span> <span class="pre">arg)</span></code>
returns a random number between the given interval.</p>
<ul>
<li><p class="first">At the normalization step:</p>
<ul>
<li><p class="first">If the parameter “thermalScaling” has been set to true, the
eigenvalue associated with each vector will be used in order to
normalize the vector.</p>
</li>
<li><p class="first">Calculation:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>For i from 1 to numberOfModes
  val = values[i]
  vec = vectors[i]
  factorNormalization = inverseEuclideanNorm(vec) * (1 / sqrt(hessianConstant * val)) //&quot;hessianConstant&quot; is a constant introduced by the user
  vec = vectorByScalar(vec, factorNormalization)
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first">When calculating the modulus for the chosen mode:</p>
<ul>
<li><p class="first">If the option “moveMagnitudeGeneration” has been set to
“scaledBiasedRandom” the eigenvalues of the chosen mode and the
first mode will be used in order to set an scaling factor for the
modulus.</p>
</li>
<li><p class="first">Calculation:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>val = values[chosenMode]
base = values[0]
scaledFactor = (0.6 * val) / base + 0.4
scaledMove = displacement / scaledFactor //&quot;displacement&quot; is a constant introduced by the user
modulus = scaledMove * rand(0.625, 1.0)
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first">When mixing the normal modes:</p>
<ul>
<li><p class="first">Eigenvalues are also used for mixing the chosen mode with the
another ones. However, PELE by default does not mix the modes, so
in order to do so, the option “modesMixingOption” must be set to
either “mixAllModesEquallyRandom” or “mixMainModeWithOthersModes”,
although the only one which will use the eigenvalues is the latter
one.</p>
</li>
<li><p class="first">Calculation (for “mixMainModeWithOthersModes” option):</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>For i from 1 to numberOfModes
  if i != from chosenModeIndex
    vec = vectors[i]
    magnitude = rand(-1.0, 1.0) / sqrt(values[i]) * inverseEuclideanNorm(vec)
    moveVector = linearCombination(magnitude, vec, 1.0, moveVector)

chosenEigenVectorWeight = mainModeWeight * inverseEuclideanNorm(chosenEigenVector)
otherModesWeight = (1.0 - mainModeWeight) * inverseEuclideanNorm(moveVector)
moveVector = linearCombination(chosenEigenVectorWeight, chosenEigenVector, otherModesWeight, moveVector);

moveVector = normalizeVector(moveVector);
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="Anm.html"
                        title="previous chapter">ANM Block in Pele++ control file</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../SideChainPrediction/SideChainPrediction.html"
                        title="next chapter">SideChainPrediction Block in Pele++ control file</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/ANM/EigenvectorsAndEigenvalues.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../SideChainPrediction/SideChainPrediction.html" title="SideChainPrediction Block in Pele++ control file"
             >next</a> |</li>
        <li class="right" >
          <a href="Anm.html" title="ANM Block in Pele++ control file"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PELE 1.5.${BUILD_TAG} documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../referenceManual.html" >Reference Manual</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../PELE/PELESimulation_index.html" >PELESimulation command</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2016 BARCELONA SUPERCOMPUTING CENTER. See the COPYRIGHT file at the top-level directory of this distribution. 
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.6.3.
    <a href="../index.html#license">License</a>.
    </div>
  </body>
</html>
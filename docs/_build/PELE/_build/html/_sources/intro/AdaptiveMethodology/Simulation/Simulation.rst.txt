#############
Simulation
#############

In this stage the AdaptivePELE input is built
and the simulation is launched

**********
Input
**********

To launch AdaptivePELE we must build 2 control files:

    - PELE controlfile
    - AdaptivePELE controlfile

===============================
AdaptivePELE controlfile
===============================

- **General Params**: These parameters control the general aspects of the simulation, such as the initial structures or the output path. For example, if you consider that a simulation did not explore the energy landscape sufficiently, it can be automatically resumed. For more informatio, please refer to: `AdaptivePELE GeneralParams section <https://adaptivepele.github.io/AdaptivePELE/Examples.html#generalparams-block>`__.

.. code-block:: json

    {
    "generalParams" : {
        "restart": false,
        "outputPath":"OUTFILES",
        "initialStructures" : ["ref.pdb"]
    },
    }

- **Spawning Block**: At the end of each iteration (called epochs), trajectories are spawned in different interesting clusters, according to a reward function. 

    The most used strategies are:

    - inverselyProportional: Distributes the processors with a weight that is inversely proportional to the cluster population.

    - epsilon: An epsilon fraction of processors are distributed proportionally to the value of a metric, and the rest are inverselyProportional distributed. A param n can be specified to only consider the n clusters with best metric.

For more spawning strategies refer to: `AdaptivePELE spawning section <https://adaptivepele.github.io/AdaptivePELE/Examples.html#spawning-block>`__

.. code-block:: json
    
    {
    "spawning" : {
        "type" : "epsilon",
        "params" : {
        "reportFilename" : "run_report",
        "metricColumnInReport" : 5,
        "epsilon" : 0.25
       }
    },
    }


- **Simulation Block**: When using PELE as a propagator, the following parameters are mandatory:

    - iterations (integer, mandatory): Number of adaptive sampling iterations to run.  [20 small number of iterations, 50 default, 100 large]

    - processors (integer, mandatory): Number of processors to use with PELE [20 small sampling, 60 default, 150 exhaustive sampling]

    - peleSteps (integer, mandatory): Number of PELE steps in a epoch (iteration). As less you have the more you will move from one area to the other but less conformational sampling you will have. [ 4 small conformational sampling but high exploration on space, 8 default, 12 exhaustive conformational sampling in a certain area but low exploration space]

    - seed (integer, mandatory): Seed for the random number generator

    - controlFile (string, mandatory): Path to the PELE control file. Check the `PELE controlFile section <../../Simulation/Simulation.html#Input>`__ for more.


For more info on the Simulation Block, please refer to: https://adaptivepele.github.io/AdaptivePELE/Examples.html#simulation-block

.. code-block:: json

        {
        "simulation": {
        "type" : "pele",
        "params" : {
            "iterations" : 20, 
            "processors" : 64, 
            "peleSteps" : 8,
            "seed": 123456,
            "controlFile" : "pele.conf"
        }
    },
    }


- **Cluster Block**: Given some clusters, a conformation is said to belong to a cluster when it differs in less than a certain metric threshold (e.g. ligand RMSD) to the corresponding cluster center. Cluster centers are always compared in the same order, and, if there is no similar cluster, it generates a new one. This clusters will be later used to spawn the processors in an Adaptive Sampling fashion.



Aside from the speed, a big advantage of using this method is that it permits the user to define different criteria in different regions. This way, we can optimize the number of clusters, giving more importance to regions with more interactions, potentially being more metastable.
In order to measure the potential metastability, we use the ratio of the number of protein-ligand heavy atom contacts over the number of ligand heavy atoms, r. Two atoms are considered to be in contact if the distance between them is less than a certain contactThreshold (8Ã… by default). Although these values depend on the particular protein-ligand geometry and ligand size, this measure is more ligand-independent compared to the overall number of contacts and a value of 1 typically indicates that the ligand is on the surface entering a protein pocket. We encourage the use of default parameters with very few exceptions such as in the study of the diffusion of ions or tiny molecules (e.g. a oxygen molecule).
For more information about the clustering block and its parameters. Please, refer to: ` AdaptivePELE cluster section <https://adaptivepele.github.io/AdaptivePELE/Examples.html#clustering-block>`__

.. code-block:: json

    {
        "clustering" : {
        "type" : "rmsd",
        "params" : {
           "ligandResname" : "DRG",
           "contactThresholdDistance" : 8
        },
        "thresholdCalculator" : {
          "type" : "heaviside",
         "params" : {
              "values" : [2,3,4,5],
              "conditions": [1.0, 0.75, 0.5]
            }
        }
    },
    }


===============================
PELE controlfile
===============================

Refer to `PELE controlFile section <../../Simulation/Simulation.html#Input>`__ to learn how to prepare a PELE controlfile.


**********************
Launch AdaptivePELE
**********************

===================
From command line
===================

Command::

    python -m AdaptivePELE.adaptiveSampling control_file

===================
From queue system
===================


Place the command before in a .sh file with
the specificacitions of your queue system and launch it

Example slurm file::

    #!/bin/bash
    #SBATCH -J PELE_MPI
    #SBATCH --output=mpi_%j.out
    #SBATCH --error=mpi_%j.err
    #SBATCH --ntasks=48
    #SBATCH --mem-per-cpu=1G
    
    
    module purge
    
    module load Python PELE/1.5.0.2524

    python -m AdaptivePELE.adaptiveSampling control_file
    
sbatch slurm.sh
